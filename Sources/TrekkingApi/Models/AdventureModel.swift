//
// AdventureModel.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public final class AdventureModel: Codable, JSONEncodable, Hashable {

    static let titleRule = StringRule(minLength: 0, maxLength: 255, pattern: nil)
    static let subTitleRule = StringRule(minLength: 0, maxLength: 255, pattern: nil)
    static let textRule = StringRule(minLength: 1, maxLength: nil, pattern: nil)
    public var id: String?
    public var createdAt: Date?
    public var updatedAt: Date?
    public var title: String
    public var subTitle: String
    public var text: String
    public var coverPhoto: String?
    public var slug: String?
    public var commentsAllowed: Bool?
    public var isPublished: Bool?
    public var freeDownload: Bool?
    public var photos: [AdventurePhoto]?
    public var videos: [String]?
    public var price: Double?
    public var level: UserAdventureLevel
    public var categoryId: String
    public var distance: Double
    public var duration: Double
    public var startDate: Date
    public var endDate: Date
    public var activityRecords: [ActivityRecord]

    public init(id: String? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, title: String, subTitle: String, text: String, coverPhoto: String? = nil, slug: String? = nil, commentsAllowed: Bool? = nil, isPublished: Bool? = nil, photos: [AdventurePhoto]? = nil, videos: [String]? = nil, freeDownload: Bool? = nil, price: Double? = nil, level: UserAdventureLevel,
                
                categoryId: String,
                distance: Double,
                duration: Double,
                startDate: Date,
                endDate: Date,
                activityRecords: [ActivityRecord]
    
    ) {
        self.id = id
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.title = title
        self.subTitle = subTitle
        self.text = text
        self.coverPhoto = coverPhoto
        self.slug = slug
        self.commentsAllowed = commentsAllowed
        self.isPublished = isPublished
        self.photos = photos
        self.videos = videos
        self.freeDownload = freeDownload
        self.price = price
        self.level = level
        self.categoryId = categoryId
        self.distance = distance
        self.duration = duration
        self.startDate = startDate
        self.endDate = endDate
        self.activityRecords = activityRecords
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case createdAt
        case updatedAt
        case title
        case subTitle
        case text
        case coverPhoto
        case slug
        case commentsAllowed
        case isPublished
        case photos
        case videos
        case freeDownload
        case price
        case level
        case categoryId
        case distance
        case duration
        case startDate
        case endDate
        case activityRecords
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(createdAt, forKey: .createdAt)
        try container.encodeIfPresent(updatedAt, forKey: .updatedAt)
        try container.encode(title, forKey: .title)
        try container.encode(subTitle, forKey: .subTitle)
        try container.encode(text, forKey: .text)
        try container.encodeIfPresent(coverPhoto, forKey: .coverPhoto)
        try container.encodeIfPresent(slug, forKey: .slug)
        try container.encodeIfPresent(commentsAllowed, forKey: .commentsAllowed)
        try container.encodeIfPresent(isPublished, forKey: .isPublished)
        try container.encodeIfPresent(photos, forKey: .photos)
        try container.encodeIfPresent(videos, forKey: .videos)
        try container.encodeIfPresent(freeDownload, forKey: .freeDownload)
        try container.encodeIfPresent(price, forKey: .price)
        try container.encodeIfPresent(level, forKey: .level)
        try container.encodeIfPresent(categoryId, forKey: .categoryId)
        try container.encodeIfPresent(distance, forKey: .distance)
        try container.encodeIfPresent(duration, forKey: .duration)
        try container.encodeIfPresent(startDate, forKey: .startDate)
        try container.encodeIfPresent(endDate, forKey: .endDate)
        try container.encodeIfPresent(activityRecords, forKey: .activityRecords)
    }

    public static func == (lhs: AdventureModel, rhs: AdventureModel) -> Bool {
        lhs.id == rhs.id &&
        lhs.createdAt == rhs.createdAt &&
        lhs.updatedAt == rhs.updatedAt &&
        lhs.title == rhs.title &&
        lhs.subTitle == rhs.subTitle &&
        lhs.text == rhs.text &&
        lhs.coverPhoto == rhs.coverPhoto &&
        lhs.slug == rhs.slug &&
        lhs.commentsAllowed == rhs.commentsAllowed &&
        lhs.isPublished == rhs.isPublished &&
        lhs.freeDownload == rhs.freeDownload &&
        lhs.photos == rhs.photos &&
        lhs.price == rhs.price &&
        lhs.level == rhs.level &&
        lhs.categoryId == rhs.categoryId &&
        lhs.distance == rhs.distance &&
        lhs.duration == rhs.duration &&
        lhs.startDate == rhs.startDate &&
        lhs.endDate == rhs.endDate &&
        lhs.activityRecords == rhs.activityRecords &&
        lhs.videos == rhs.videos
        
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id?.hashValue)
        hasher.combine(createdAt?.hashValue)
        hasher.combine(updatedAt?.hashValue)
        hasher.combine(title.hashValue)
        hasher.combine(subTitle.hashValue)
        hasher.combine(text.hashValue)
        hasher.combine(coverPhoto?.hashValue)
        hasher.combine(slug?.hashValue)
        hasher.combine(commentsAllowed?.hashValue)
        hasher.combine(isPublished?.hashValue)
        hasher.combine(freeDownload?.hashValue)
        hasher.combine(photos?.hashValue)
        hasher.combine(videos?.hashValue)
        hasher.combine(price?.hashValue)
        hasher.combine(level.hashValue)
        hasher.combine(categoryId.hashValue)
        hasher.combine(distance.hashValue)
        hasher.combine(duration.hashValue)
        hasher.combine(startDate.hashValue)
        hasher.combine(endDate.hashValue)
        hasher.combine(activityRecords.hashValue)
        
    }
}

